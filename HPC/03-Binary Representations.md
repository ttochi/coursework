# Binary Representation

Unsigned number
-

signed 이진수
- signed bit를 두어서 0이면 양수, 1이면 음수
- 하지만 얘는 0이 2개가 되는 케이스: 하드웨어에서 0을 2개 처리하는게 복잡: 이제는 안쓴다
- 2의 보수표현으로 해결


## 보수

- (r-1)의 보수
- r의 보수

### r-1

각 자리의 숫자를 (r-1)에서 빼는 것

9의 보수: 각 자리 숫자를 9에서 뺌
836의 보수 = 999 - 836 = 163

이를 정리하면 (r^n-1)에서 대상 숫자를 빼면 됨

### 2의 보수

1의 보수를 구한 뒤 1을 더하면 됨

---

## mod 연산

유클리드 나눗셈에서는
-7을 3으로 나누면 몫이 -3이고 나머지가 2

## 합동관계

x % m == y % m

x = y (mod m)

32개의 bit가 있는데 계산 결과가 32 bit를 넘어가는 경우

23/16=7

23은 10111
근데 우리가 4bit만 써야한다 --> 0111 7이 남음

23 = 7 (mod 16)

`데이터 유실이 아닌가??ㅜㅜ 왜 하는지?`

## OR AND NOT

이거로 사칙연산을 다 할 수 있다

XOR: x, y 두 비트가 다르면 1이고 같으면 0
XNOR: 같으면 1이고 다르면 0

XOR도 결국 AND OR NOT으로 표현이 가능 `18p`

boolean algebra를 하드웨어롤 어떻게 표현할거냐?
--> 논리게이트

논리게이트로 boole 함수를 구현
--> 즉 출력 하나짜리 함수를 만들 수 있다.

이러한 함수를 여러 개 이어서 n개의 입력, m개의 출력을 만드는 함수를 구현할 수 있음

이러한 실제 구현을 abstract 시킨다 --> 블랙박스

> 첫 숙제가 c에서 bit sequence를 들여다보는게 나갈 것
컴퓨터 안에서 number가 어떤식으로 representation 되는가
32bit floating point representation

> AI에서 Qunatization: 32bit로 표현하는 floating point를 16bit로 표현해도 별로 손실이 없더라

## 시프트 연산

> 20p 오타임

-   논리시프트: 0으로 채움
-   산술시프트: 부호표현을 유지하며 채움

> 왼쪽 시프트는 논리시프트와 산술시프트가 동일
> 오른쪽 시프트가 논리인지 산술인지는 컴파일러 구현에 따라 다름

### 왼쪽 shift (곱셈)

m번 shift (m은 n비트 수보단 작아야..)
2^m을 곱한 것과 동일

> 부호없는 수와 2의 보수표현에서 유효

### 오른쪽 shift (나눗셈)

Unsigned (부호없는 수)
: 2^m을 나눈 몫

Signed
: 산술시프트일 때만 2^m을 나눈 몫 (음수일 땐, 유클리안 디비전으로 생각)

```
1001(-7) --> 1110(-2)

유클리안 계산법으로
-7 / 4 = -2 (mod 1)
-7 = 4*(-2)+1
```

질문있습니다!
22p에서 x<0일 때 m만큼 오른쪽 쉬프트한 것이 2^m을 나누어 몫을 취하는 것이 아니다라고 적혀있는데요, 유클리디안 나눗셈이 아니라 일반적이 나눗셈으로 생각해서 그런걸까요?

## 부호 확장

확장되는 비트를 부호비트로 채운다

```
4비트 2의 보수표현을 6비트로 변환

0101(6) --> 000101(-6)
1101(-3:0011) --> 111101(-3:000011)
```

우리가 보수를 구할 때 오른쪽 가장 오른쪽에 나온 1 직전까지를 뒤집는다

그러니, 음수의 경우 앞에를 쭉 1로 채워져야 뒤집었을 때 값이 0으로 채워지는 것과 동일해짐

## 덧셈 연산

### Unsigned

overflow: 두 이진수를 더할 때, MSB에서 나오는 carry가 1인 경우

overflow 발생 시 2^n 만큼 빼줌

(x+y) mod 2^n

즉, 오버플로 발생 시 덧셈 결과로 나온 n+1개 비트 중 하위 n개 비트를 취하고 MSB를 무시 --> (합동관계를 취한다)

### Signed

overflow: `더하는 과정에서 MSB로 나오는 carry`랑 `MSB의 carry`가 서로 다른 경우

x, y의 부호비트가 동일한데 MSB의 carry가 다를 때

```
 0 1 1 1
   0 1 1 1
+  0 1 1 1
-----------
   1 1 1 0

7+7=14
14는 4비트 보수로 표현할 수 없음 (7이 최대)
```

-   양수로 오버플로우: 2^n만큼 빼줌
-   음수로 오버플로우: 2^n만큼 더해줌

> 이 모든 것을 왜 배우냐? 덧셈 하드웨어를 구현하기 위해서!

### 하드웨어 구현

AND, OR, NOT (functionally complete set)
: 이 3개로 회로를 구현할 수 있다

> complete set의 조합은 다양함

-   반가산기: 2개 비트 덧셈하는 회로 (half-adder)
-   전가산기: 3개 비트 덧셈하는 회로 (full-adder)

가산기 자체가 자세히 어떻게 생겼나를 신경쓰지 않고 abstract 시킴

전가산기 n개를 이용해서 n비트의 unsigned 덧셈 하드웨어를 구현할 수 있다

signed는?
unsigned와 동일하지만 다만, overflow 발생을 detect하기 위해 최종 carry와 직전 carry에 대한 xor 연산기를 추가


## 뺄셈 연산

Unsigned
: 십진수 뺄셈과 동일 `33p`

Signed
: y의 2의 보수를 더해주는 것과 동일

```
x-y = x+(-y) = x+y'+1
```

### 하드웨어 구현

덧셈에서처럼 반감산기과 전감산기를 구현할 수 있음

2의 보수표현에서는 감산기를 따로 구현할 필요 없이 가산기를 이용해서 구현할 수 있음 `36p`

subtract값이 0이면 덧셈, 1이면 뺄셈을 수행하는 연산기
subtract가 1이면 y의 1의보수가 되고 cin이 1이 들어가서 1을 추가로 더해주는 형식이 됨

**이런게 바로 ALU에 들어가는 덧셈,뺄셈 하드웨어이다.**
근데 저 연산기가 실제로 들어가는건 아니다?? 비효율적이래

## 곱셈 연산

> 이런걸 시험문제에 내진 않을거다?

### Unsigned

십진수 곱셈과 동일 `37p`

이진수의 곱셈에서 1비트 곱셈의 결과는 무조건 0이나 1이기 때문에 carry가 발생하지 않음

> 곱하기지만 AND 연산으로 표현할 수 있다

Unsigned 곱셈 하드웨어도 덧셈 하드웨어만 있으면 구현이 가능 `38p`

> 예전엔 곱셈기가 덧셈기보다 비쌌다. 근데 요즘은 많은 최적화가 적용되어서 덧셈기와 곱셈기가 거의 또이또이

### Signed

얘도 마찬가지로 덧셈기로 구현 가능

## 나눗셈 연산

Unsigned

-   십진수 나눗셈과 동일
-   y가 x에 몇 개 들어있는 지 반복해서 빼보는 것
-   23 / 4 --> 23-4를 총 5번 할 수 있다

Signed

-   절대값으로 unsigned 나눗셈 수행
-   x와 y의 부호가 다르면 몫을 -로 취함
-   x<0 이면 나머지를 -로 취함

내용이 복잡하지만 결론은,
**나눗셈의 하드웨어도 감산기를 이용해서 만들 수 있다!**

> 아직까지 나눗셈은 덧셈기 곱셈기보다 10배 이상 느리다

## 정리

AND OR NOT 게이트로 2의 보수표현에 대한 덧셈, 뺄셈, 곱셈, 나눗셈을 할 수 있는 하드웨어를 만들 수 있다는 것

특히 덧셈을 표현할 수 있으면 나머지도 표현이 가능하다

CPU의 ALU 안에 이러한 연산기들이 들어가 있으면 되는 것

Control Unit 만드는건 조금 복잡..
폰노이만에서 Fetch/Decode 하는...
register


지금 보여주는 것은 원리를 이해하기 위한 비효율적인 회로를 보여준 것
실제로는 특허도 많고 구현체가 다양하다
